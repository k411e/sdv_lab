// This file is @generated by prost-build.
/// The UUID datamodel per <https://www.rfc-editor.org/rfc/rfc9562\[RFC> 9562\]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Uuid {
    /// Most significant bits
    #[prost(fixed64, tag = "1")]
    pub msb: u64,
    /// Least significant bits
    #[prost(fixed64, tag = "2")]
    pub lsb: u64,
}
/// Data model definition for source and destination addressing of messages sent to/from
/// devices, services, methods, topics, etc...
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UUri {
    /// Authority Name.
    ///
    /// Could be the host name, ip address, device & domain names, etc..
    #[prost(string, tag = "1")]
    pub authority_name: ::prost::alloc::string::String,
    /// Software Entity (uEntity) Identifiers.
    #[prost(uint32, tag = "2")]
    pub ue_id: u32,
    /// Software Entity (uEntity) major version number.
    #[prost(uint32, tag = "3")]
    pub ue_version_major: u32,
    /// uEntity resource id.
    ///
    /// Identifier used to represent either a method, publish topic, or notification topic.
    #[prost(uint32, tag = "4")]
    pub resource_id: u32,
}
/// List of URIs that can be used for batching APIs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UUriBatch {
    #[prost(message, repeated, tag = "1")]
    pub uris: ::prost::alloc::vec::Vec<UUri>,
}
/// Canonical Error codes for uProtocol APIs
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UCode {
    /// Completes successfully
    Ok = 0,
    /// Operation has been cancelled by the caller
    Cancelled = 1,
    /// An unknown (but not critical) error has occurred
    Unknown = 2,
    /// Passed arguments are invalid (ex. improperly formatted)
    InvalidArgument = 3,
    /// Operation has expired (timeout)
    DeadlineExceeded = 4,
    /// Operation cannot be completed because the requested entity was not
    /// found (ex. database lookup and the data is not found)
    /// Calling uE *MAY* retry the operation with back-off
    NotFound = 5,
    /// The calling uE requested to add/create something that already exists
    /// (ex. add to a database something that is already there)
    AlreadyExists = 6,
    /// The calling uE is authenticated but not permitted to call the API
    PermissionDenied = 7,
    /// The calling uE does not have valid authentication credentials for the API
    Unauthenticated = 16,
    /// The resource being accessed has been exhausted (ex. out of disk space, etc...)
    ResourceExhausted = 8,
    /// The system (service) is in a state that it cannot handle the request
    /// Calling uEs *SHOULD NOT* retry till the system state has been corrected
    FailedPrecondition = 9,
    /// The operation was aborted, typically due to a concurrency issue such as
    /// a sequencer check failure or transaction abort
    /// Calling uEs *MAY* retry but at a higher frequency than UNAVAILABLE
    Aborted = 10,
    /// A caller would typically iterating through the results from said API
    /// and can is expected to detect the end of the results (out of range)
    OutOfRange = 11,
    /// Part or all of the requested operation has not been implemented yet
    Unimplemented = 12,
    /// A serious internal error has not described by a known error code
    Internal = 13,
    /// The operation is currently unavailable
    /// Calling uEs *MAY* retry with back-off
    Unavailable = 14,
    /// When an unrecoverable data loss or corruption has occurred
    DataLoss = 15,
}
impl UCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Ok => "OK",
            Self::Cancelled => "CANCELLED",
            Self::Unknown => "UNKNOWN",
            Self::InvalidArgument => "INVALID_ARGUMENT",
            Self::DeadlineExceeded => "DEADLINE_EXCEEDED",
            Self::NotFound => "NOT_FOUND",
            Self::AlreadyExists => "ALREADY_EXISTS",
            Self::PermissionDenied => "PERMISSION_DENIED",
            Self::Unauthenticated => "UNAUTHENTICATED",
            Self::ResourceExhausted => "RESOURCE_EXHAUSTED",
            Self::FailedPrecondition => "FAILED_PRECONDITION",
            Self::Aborted => "ABORTED",
            Self::OutOfRange => "OUT_OF_RANGE",
            Self::Unimplemented => "UNIMPLEMENTED",
            Self::Internal => "INTERNAL",
            Self::Unavailable => "UNAVAILABLE",
            Self::DataLoss => "DATA_LOSS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OK" => Some(Self::Ok),
            "CANCELLED" => Some(Self::Cancelled),
            "UNKNOWN" => Some(Self::Unknown),
            "INVALID_ARGUMENT" => Some(Self::InvalidArgument),
            "DEADLINE_EXCEEDED" => Some(Self::DeadlineExceeded),
            "NOT_FOUND" => Some(Self::NotFound),
            "ALREADY_EXISTS" => Some(Self::AlreadyExists),
            "PERMISSION_DENIED" => Some(Self::PermissionDenied),
            "UNAUTHENTICATED" => Some(Self::Unauthenticated),
            "RESOURCE_EXHAUSTED" => Some(Self::ResourceExhausted),
            "FAILED_PRECONDITION" => Some(Self::FailedPrecondition),
            "ABORTED" => Some(Self::Aborted),
            "OUT_OF_RANGE" => Some(Self::OutOfRange),
            "UNIMPLEMENTED" => Some(Self::Unimplemented),
            "INTERNAL" => Some(Self::Internal),
            "UNAVAILABLE" => Some(Self::Unavailable),
            "DATA_LOSS" => Some(Self::DataLoss),
            _ => None,
        }
    }
}
/// Metadata describing a particular message's purpose, content and processing requirements.
/// Each type of message is described by a set of mandatory and optional attributes.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UAttributes {
    /// A unique message identifier.
    #[prost(message, optional, tag = "1")]
    pub id: ::core::option::Option<Uuid>,
    /// This message's type which also indicates its purpose and determines contraints on the other properties.
    #[prost(enumeration = "UMessageType", tag = "2")]
    pub r#type: i32,
    /// The origin (address) of this message.
    #[prost(message, optional, tag = "3")]
    pub source: ::core::option::Option<UUri>,
    /// The destination (address) of this message.
    #[prost(message, optional, tag = "4")]
    pub sink: ::core::option::Option<UUri>,
    /// The QoS level that this message should be processed/delivered with.
    #[prost(enumeration = "UPriority", tag = "5")]
    pub priority: i32,
    /// The amount of time (in milliseconds) after which this message MUST NOT be delivered/processed anymore.
    #[prost(uint32, optional, tag = "6")]
    pub ttl: ::core::option::Option<u32>,
    /// The service consumer's permission level.
    #[prost(uint32, optional, tag = "7")]
    pub permission_level: ::core::option::Option<u32>,
    /// A UCode indicating an error that has occurred
    /// during the delivery of either an RPC Request or Response message.
    #[prost(enumeration = "UCode", optional, tag = "8")]
    pub commstatus: ::core::option::Option<i32>,
    /// The identifier that a service consumer can use to correlate an RPC Repsonse message with its RPC Request.
    #[prost(message, optional, tag = "9")]
    pub reqid: ::core::option::Option<Uuid>,
    /// The service consumer's access token.
    #[prost(string, optional, tag = "10")]
    pub token: ::core::option::Option<::prost::alloc::string::String>,
    /// A tracing identifier to use for correlating messages across the system.
    /// Intended to be compatible with <https://github.com/cloudevents/spec/blob/main/cloudevents/extensions/distributed-tracing.md>
    #[prost(string, optional, tag = "11")]
    pub traceparent: ::core::option::Option<::prost::alloc::string::String>,
    /// The format for the data stored in the UMessage.
    #[prost(enumeration = "UPayloadFormat", tag = "12")]
    pub payload_format: i32,
}
/// uProtocol defines different types of messages.
/// Using the message type, validation can be performed to ensure transport
/// validity of the data in the {@link UAttributes}.
///
/// The "up-" prefix used in the uprotocol.ce_name options has been introduced
/// to allow distinguishing between existing CloudEvents being exchanged by
/// legacy systems using a predecessor of Eclipse uProtocol and CloudEvents
/// conforming to the mapping rules defined in the Eclipse uProtocol specification.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UMessageType {
    /// Unspecified message type
    UmessageTypeUnspecified = 0,
    /// Publish
    /// A message that is used to notify all interested consumers of an event that has occurred.
    UmessageTypePublish = 1,
    /// RPC Request
    /// A message that is used by a service consumer to invoke one of a service provider's methods with some input data, expecting the service
    /// provider to reply with a response message.
    UmessageTypeRequest = 2,
    /// RPC Response
    /// A message that is used by a service provider to send the outcome of processing a request message
    /// from a servcice consumer.
    UmessageTypeResponse = 3,
    /// Notification
    /// A message that is used to inform a specific consumer about an event that has occurred.
    UmessageTypeNotification = 4,
}
impl UMessageType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UmessageTypeUnspecified => "UMESSAGE_TYPE_UNSPECIFIED",
            Self::UmessageTypePublish => "UMESSAGE_TYPE_PUBLISH",
            Self::UmessageTypeRequest => "UMESSAGE_TYPE_REQUEST",
            Self::UmessageTypeResponse => "UMESSAGE_TYPE_RESPONSE",
            Self::UmessageTypeNotification => "UMESSAGE_TYPE_NOTIFICATION",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UMESSAGE_TYPE_UNSPECIFIED" => Some(Self::UmessageTypeUnspecified),
            "UMESSAGE_TYPE_PUBLISH" => Some(Self::UmessageTypePublish),
            "UMESSAGE_TYPE_REQUEST" => Some(Self::UmessageTypeRequest),
            "UMESSAGE_TYPE_RESPONSE" => Some(Self::UmessageTypeResponse),
            "UMESSAGE_TYPE_NOTIFICATION" => Some(Self::UmessageTypeNotification),
            _ => None,
        }
    }
}
/// uProtocol Priority as defined in
/// <https://github.com/eclipse-uprotocol/up-spec/blob/main/basics/qos.adoc\[uProtocol> Prioritization\]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UPriority {
    /// Unspecified priority
    UpriorityUnspecified = 0,
    /// Low Priority. No bandwidth assurance such as File Transfer.
    UpriorityCs0 = 1,
    /// Standard, undifferentiated application such as General (unclassified).
    UpriorityCs1 = 2,
    /// Operations, Administration, and Management such as Streamer messages (sub, connect, etc…)
    UpriorityCs2 = 3,
    /// Multimedia streaming such as Video Streaming
    UpriorityCs3 = 4,
    /// Real-time interactive such as High priority (rpc events)
    UpriorityCs4 = 5,
    /// Signaling such as Important
    UpriorityCs5 = 6,
    /// Network control such as Safety Critical
    UpriorityCs6 = 7,
}
impl UPriority {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UpriorityUnspecified => "UPRIORITY_UNSPECIFIED",
            Self::UpriorityCs0 => "UPRIORITY_CS0",
            Self::UpriorityCs1 => "UPRIORITY_CS1",
            Self::UpriorityCs2 => "UPRIORITY_CS2",
            Self::UpriorityCs3 => "UPRIORITY_CS3",
            Self::UpriorityCs4 => "UPRIORITY_CS4",
            Self::UpriorityCs5 => "UPRIORITY_CS5",
            Self::UpriorityCs6 => "UPRIORITY_CS6",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPRIORITY_UNSPECIFIED" => Some(Self::UpriorityUnspecified),
            "UPRIORITY_CS0" => Some(Self::UpriorityCs0),
            "UPRIORITY_CS1" => Some(Self::UpriorityCs1),
            "UPRIORITY_CS2" => Some(Self::UpriorityCs2),
            "UPRIORITY_CS3" => Some(Self::UpriorityCs3),
            "UPRIORITY_CS4" => Some(Self::UpriorityCs4),
            "UPRIORITY_CS5" => Some(Self::UpriorityCs5),
            "UPRIORITY_CS6" => Some(Self::UpriorityCs6),
            _ => None,
        }
    }
}
/// The format for the data stored in the UMessage.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UPayloadFormat {
    /// Payload format is unknown.
    UpayloadFormatUnspecified = 0,
    /// Payload is an Any protobuf message that contains the packed payload
    UpayloadFormatProtobufWrappedInAny = 1,
    /// Protobuf serialization format
    UpayloadFormatProtobuf = 2,
    /// JSON serialization format
    UpayloadFormatJson = 3,
    /// Basic SOME/IP serialization format
    UpayloadFormatSomeip = 4,
    /// SOME/IP TLV format
    UpayloadFormatSomeipTlv = 5,
    /// RAW (binary) format
    UpayloadFormatRaw = 6,
    /// Text format
    UpayloadFormatText = 7,
    /// Shared memory format
    UpayloadFormatShm = 8,
}
impl UPayloadFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UpayloadFormatUnspecified => "UPAYLOAD_FORMAT_UNSPECIFIED",
            Self::UpayloadFormatProtobufWrappedInAny => {
                "UPAYLOAD_FORMAT_PROTOBUF_WRAPPED_IN_ANY"
            }
            Self::UpayloadFormatProtobuf => "UPAYLOAD_FORMAT_PROTOBUF",
            Self::UpayloadFormatJson => "UPAYLOAD_FORMAT_JSON",
            Self::UpayloadFormatSomeip => "UPAYLOAD_FORMAT_SOMEIP",
            Self::UpayloadFormatSomeipTlv => "UPAYLOAD_FORMAT_SOMEIP_TLV",
            Self::UpayloadFormatRaw => "UPAYLOAD_FORMAT_RAW",
            Self::UpayloadFormatText => "UPAYLOAD_FORMAT_TEXT",
            Self::UpayloadFormatShm => "UPAYLOAD_FORMAT_SHM",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UPAYLOAD_FORMAT_UNSPECIFIED" => Some(Self::UpayloadFormatUnspecified),
            "UPAYLOAD_FORMAT_PROTOBUF_WRAPPED_IN_ANY" => {
                Some(Self::UpayloadFormatProtobufWrappedInAny)
            }
            "UPAYLOAD_FORMAT_PROTOBUF" => Some(Self::UpayloadFormatProtobuf),
            "UPAYLOAD_FORMAT_JSON" => Some(Self::UpayloadFormatJson),
            "UPAYLOAD_FORMAT_SOMEIP" => Some(Self::UpayloadFormatSomeip),
            "UPAYLOAD_FORMAT_SOMEIP_TLV" => Some(Self::UpayloadFormatSomeipTlv),
            "UPAYLOAD_FORMAT_RAW" => Some(Self::UpayloadFormatRaw),
            "UPAYLOAD_FORMAT_TEXT" => Some(Self::UpayloadFormatText),
            "UPAYLOAD_FORMAT_SHM" => Some(Self::UpayloadFormatShm),
            _ => None,
        }
    }
}
/// UMessage is the top-level message type for the uProtocol.
/// It contains a header (UAttributes), and payload and is a way of representing a
/// message that would be sent between two uEs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UMessage {
    /// uProtocol mandatory and optional attributes
    #[prost(message, optional, tag = "1")]
    pub attributes: ::core::option::Option<UAttributes>,
    /// Optional message payload
    #[prost(bytes = "vec", optional, tag = "2")]
    pub payload: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
/// uProtocol Error model for all uProtocol APIs that is loosly based off
/// google.rpc.Status
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UStatus {
    /// The status code.
    #[prost(enumeration = "UCode", tag = "1")]
    pub code: i32,
    /// A developer-facing error message, which should be in English. Any
    /// user-facing error message should be localized and sent in the
    /// details field, or localized by the client.
    #[prost(string, optional, tag = "2")]
    pub message: ::core::option::Option<::prost::alloc::string::String>,
    /// A list of messages that carry the error details.  There is a common set of
    /// message types for APIs to use.
    #[prost(message, repeated, tag = "3")]
    pub details: ::prost::alloc::vec::Vec<::prost_types::Any>,
}
/// File Message
/// Files can be attached to uProtocol in the headers
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct File {
    /// RFC8089 formatted filename URI
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// File size attribute
    #[prost(uint64, optional, tag = "2")]
    pub size: ::core::option::Option<u64>,
    /// Optional file checksum
    #[prost(message, optional, tag = "3")]
    pub checksum: ::core::option::Option<Checksum>,
}
/// Collection of Files (batch)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileBatch {
    /// Repeated list of 0 to n attached files
    #[prost(message, repeated, tag = "1")]
    pub files: ::prost::alloc::vec::Vec<File>,
}
/// File Checksum
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Checksum {
    /// Type of Checksum
    #[prost(enumeration = "ChecksumType", tag = "1")]
    pub r#type: i32,
    /// The checksum value
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
/// Checksum type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ChecksumType {
    /// Unspecified
    Unspecified = 0,
    /// MD5SUM
    Md5 = 1,
    /// SHA1SUM
    Sha1 = 2,
}
impl ChecksumType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "CHECKSUM_TYPE_UNSPECIFIED",
            Self::Md5 => "CHECKSUM_TYPE_MD5",
            Self::Sha1 => "CHECKSUM_TYPE_SHA1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "CHECKSUM_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "CHECKSUM_TYPE_MD5" => Some(Self::Md5),
            "CHECKSUM_TYPE_SHA1" => Some(Self::Sha1),
            _ => None,
        }
    }
}
